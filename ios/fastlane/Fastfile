
# fastlane_version "2.112.0"
default_platform :ios

platform :ios do

  #firim token
  FirToken = "*"
  #Ëí≤ÂêåËã±
  PgyerApiKey = "*"

  # Áîü‰∫ßÂåÖÁõÆÂΩï
  ProductionDir  = "/Users/#{`whoami`}/Desktop/app_appStore".gsub("\n", "")
  # ÂºÄÂèëÂåÖÁõÆÂΩï
  DevelopmentDir  = "/Users/#{`whoami`}/Desktop/app_development".gsub("\n", "")


=begin
Ëøô‰∏™ lane Áî®‰∫éÊûÑÂª∫Â∫îÁî®Á®ãÂ∫èÂïÜÂ∫óÂåÖ„ÄÇ

ÂèÇÊï∞Ôºö
- :to: ÈÉ®ÁΩ≤Âπ≥Âè∞ "pgy/fir/release", ÈªòËÆ§‰∏∫ "release"
- :en: ÊûÑÂª∫ÁéØÂ¢É "test/pre/prod", ÈªòËÆ§ "prod"
=end
  desc "ÊâìÂåÖ release ÁâàÊú¨, to: pgy/fir/release"
  lane :release do |options|
    stime = archiveExecutionStart();

    platform = options[:to] || "release"
    en = options[:en] || "prod"

    sh "cd .. && cd .."
    sh "flutter build ios --release lib/main_#{en}.dart"
    fileDir = getTargetDir(platform: platform)
    archiveRelease(ipaDir: fileDir)

    sh "fastlane releaseupload to:#{platform}"

    UI.message "#{ipaDir}"
    archiveExecutionEnd(stime: stime)
  end


  desc "‰∏ä‰º† release ÁâàÊú¨, to: pgy/fir/release"
  lane :releaseupload do |options|
    platform = options[:to] || "release"
    
    if platform.start_with?"rel" 
      uploadRelease(ipaDir: ProductionDir)
    elsif platform.start_with?"fir" 
      uploadFir(ipaDir: ProductionDir)
    else
      uploadPgyer(ipaDir: ProductionDir)
    end
  
  end

=begin
Ëøô‰∏™ lane Áî®‰∫éÊûÑÂª∫Â∫îÁî®Á®ãÂ∫èÂºÄÂèëÂåÖ„ÄÇ

ÂèÇÊï∞Ôºö
- :to: ÈÉ®ÁΩ≤Âπ≥Âè∞ "pgy/fir", ÈªòËÆ§‰∏∫ "pgy"
- :en: ÊûÑÂª∫ÁéØÂ¢É "test/pre/prod", ÈªòËÆ§ "pre"
=end
  desc "ÊâìÂåÖ development ÁâàÊú¨, to: pgy/fir"
  lane :develop do |options|
    stime = archiveExecutionStart();

    platform = options[:to] ||"pgy"
    en = options[:en] || "pre"

    sh "cd .. && cd .."
    sh "flutter build ios --release lib/main_#{en}.dart"
    fileDir = getTargetDir(platform: platform)
    archiveDevelopment(ipaDir: fileDir)

    sh "fastlane developupload to:#{platform}"

    UI.message "#{ipaDir}"
    archiveExecutionEnd(stime: stime)
  end


  desc "‰∏ä‰º† develop ÁâàÊú¨, to: pgy/fir"
  lane :developupload do |options|
    platform = options[:to] || "pgy"

    fileDir = getTargetDir(platform: platform)
    if platform.start_with?"fir" 
      uploadFir(ipaDir: fileDir)
    else
      uploadPgyer(ipaDir: fileDir)
    end
  
  end


  desc "[ÈÄöÁî®]ÂèëÂ∏ÉÊñ∞ÁâàÊú¨Âà∞ AppStore"
  def archiveRelease(name: ENV["Scheme_Name"], ipaDir: ProductionDir)
    clear_cache_files()
    # cocoapods()
    updateBuildVersion(showHash: false)
    gym(
      output_directory: ipaDir,
      scheme: name,
      export_method: 'app-store',
      export_options: {
        xcargs: "-allowProvisioningUpdates",
        iCloudContainerEnvironment: 'Production',
        provisioningProfiles:{
#           "com.yilian.ylHealthApp" => "health_prod",
            "#{ENV["App_bundleid"]}" => "#{ENV["App_mobileprovision_prod"]}",
        }
      }
    )
  end


  desc "[ÈÄöÁî®]ÂèëÂ∏ÉÊñ∞ÁâàÊú¨Âà∞ AppStore"
  def uploadRelease(name: ENV["Scheme_Name"], ipaDir: ProductionDir)
    deliver(force: true,
      # ipa: "/Users/shang/ACS/access-admin-app-ios/ipa_appStore/AccessControlSystem.ipa",
      ipa: "#{ipaDir}/#{name}.ipa",
      metadata_path: ENV["Metadata_Path"], 
      screenshots_path: ENV["Screenshots_Path"], 
    )
    # system "open #{ipaDir}"
    handleDingTalk(name: name, ipaDir: ipaDir, downloadUrl: ENV["App_Store_Link"])
  end 


  desc "[ÈÄöÁî®]ÂèëÂ∏ÉÊñ∞ÁâàÊú¨Âà∞ fir"
  def archiveDevelopment(name: ENV["Scheme_Name"], ipaDir: DevelopmentDir)
    updateBuildVersion(showHash: false)
    gym(
      clean: false,
      include_symbols: true,
      output_directory: ipaDir,
      scheme: name,
      # configuration: 'Debug',
      configuration: 'Release',
      export_method: 'development',
      export_options: {
        method: 'development',
        iCloudContainerEnvironment: 'Development',
        provisioningProfiles:{
          "#{ENV["App_bundleid"]}" => "#{ENV["App_mobileprovision_dev"]}",
        }
      }
    )
  end


  desc "‰∏ä‰º†ipad Âà∞ firim"
  def uploadFir(name: ENV["Scheme_Name"], ipaDir: DevelopmentDir, firToken: FirToken)
    firim(firim_api_token: firToken, icon: ENV["App_Icon_Local"], ipa: "#{ipaDir}/#{name}.ipa")
    handleDingTalk(name: name, ipaDir: ipaDir, downloadUrl: ENV["Firim_Shortcut_Link"])
  end


  desc "‰∏ä‰º†ipad Âà∞ Pgyer"
  def uploadPgyer(name: ENV["Scheme_Name"], ipaDir: DevelopmentDir, apiKey: PgyerApiKey)
    # uploadtime = Time.now.strftime("%Y%m%d%H%M")
    uploadtime = Time.now.strftime("%Y-%m-%d %H:%M:%S")

    response = pgyer(api_key: apiKey, 
      # update_description: "fastlaneËá™Âä®ÊâìÂåÖ‰∏ä‰º†ÊµãËØï pgyer",  
      update_description: "#{uploadtime}", 
      install_type: "1",
      ipa: "#{ipaDir}/#{name}.ipa",
    )
    puts "pgyer response: #{response.to_json}"
    puts "pgyer buildQRCodeURL: #{response["buildQRCodeURL"]}"

    # handleDingTalk(name: name, ipaDir: ipaDir, downloadUrl: ENV["Pgyer_Shortcut_Link"], qrcodeURL: response["buildQRCodeURL"])
  end

  desc "webhook ÈíâÈíâ"
  def handleDingTalk(name: ENV["Scheme_Name"], ipaDir: DevelopmentDir, downloadUrl: ENV["Firim_Shortcut_Link"], qrcodeURL: ENV["Firim_Shortcut_Link"])
    appPath = ipaDir + "/#{name}.ipa" 
    params = {appPath: appPath,
              # appIcon: ENV["App_Icon_Link"],
              appIcon: qrcodeURL,
              dingUrl: ENV["Dingtalk_Url"],
              slogan: ENV["APP_Slogan"],
              downloadUrl: downloadUrl,
              }
    puts "---#{params.to_json}--"
    dingdingtalk_robot(params)
  end


  desc "Êé®ÈÄÅÈÄöÁü•Âà∞slack"
  def handleDingSlack(name: ENV["Scheme_Name"], ipaDir: DevelopmentDir, downloadUrl: ENV["Firim_Shortcut_Link"])
    appPath = ipaDir + "/#{name}.ipa" 
    params = {appPath: appPath,
              appIcon: ENV["App_Icon_Link"],
              slackUrl: ENV["Slack_Url"],
              slogan: ENV["APP_Slogan"],  
              downloadUrl: downloadUrl           
              }
    puts "---#{params.to_json}--"
    dingslack_robot(params)
  end


  # desc("increase the current_project_version config based on configuration")
  # lane :increase_build do |option|
      
  #   fastlane_require 'Xcodeproj'
    
  #   project = "Runner/#{urProjectName.xcodeproj}"
  #   target = "Runner"
  #   buildConfiguration = <#release_configuration_name#> 
  #   CUSTOM_BUILD_NUMBER = "#{Time.now.strftime("%Y%m%d%H%M")}"

  #   project = Xcodeproj::Project.open(project)
  #   project.targets.each do |mtarget|
  #       if mtarget.name == target
  #           mtarget.build_configurations.each do |mbuild|
  #               if mbuild.name == buildConfiguration
  #                   CUSTOM_BUILD_NUMBER = mbuild.build_settings['CURRENT_PROJECT_VERSION']
  #                   mbuild.build_settings['CURRENT_PROJECT_VERSION'] = CUSTOM_BUILD_NUMBER.to_i + 1
  #               end
  #           end
  #       end
  #   end
  #   project.save()
  # end


  desc "archive sign: develop/release, to: pgy/fir/release, target: A/B/C"
  lane :archive do |options|
    platform = options[:to] || "pgy"
    target = options[:target]
    targetInfo = target ? "--env target#{target.capitalize}" : ""
    # puts "_#{sign}_#{platform}_#{target}_#{targetInfo}_"

    if sign != ""
      if sign.start_with?"rel" 
        sh "fastlane release to:#{platform} #{targetInfo}"
      else
        sh "fastlane develop to:#{platform} #{targetInfo}"
      end
    end

    if platform != "" 
      sh "fastlane upload to:#{platform} #{targetInfo}"
    end
      
  end

 
  desc "upload sign: develop/release, to:pgy/fir/release, target: A/B/C"
  lane :upload do |options|
    platform = options[:to] || "pgy"
    target = options[:target]
    targetInfo = target ? "--env target#{target.capitalize}" : ""
    # puts "_#{sign}_#{platform}_#{target}_#{targetInfo}_"

    if sign.start_with?"rel" 
      sh "fastlane releaseupload to:#{platform} #{targetInfo}"
    else
      sh "fastlane developupload to:#{platform} #{targetInfo}"
    end
      
  end


  # ÁßíËΩ¨Êó∂ÂàÜÁßí
  def seconds_to_hms(seconds)
    # ËÆ°ÁÆóÂ∞èÊó∂Êï∞
    hours = seconds / 3600
    # ËÆ°ÁÆóÂâ©‰ΩôÁöÑÁßíÊï∞Âπ∂ËΩ¨Êç¢‰∏∫ÂàÜÈíüÊï∞
    minutes = (seconds % 3600) / 60
    # ËÆ°ÁÆóÂâ©‰ΩôÁöÑÁßíÊï∞
    seconds = seconds % 60

    result = format("%02d:%02d:%02d", hours, minutes, seconds)
    return result;
  end


  # ÊâìÂåÖÂºÄÂßã
  def archiveExecutionStart()
    stime = Time.now();
    UI.message "üåüüåüüåüüåü ÊâìÂåÖÂºÄÂßã".blue
    return stime;
  end

  # ÊâìÂåÖÊó∂ÈïøÁªüËÆ°ÂáΩÊï∞
  def archiveExecutionEnd(stime: Time?)
    etime = Time.now

    # ËÆ°ÁÆóÊó∂Èó¥Â∑Æ
    time_difference = etime - stime

    UI.message "üåüüåüüåüüåü ÊâìÂåÖÁªìÊùü, ÊÄªËÄóÊó∂: #{seconds_to_hms(time_difference)}".blue
  end

  # ÂΩìÂâçÁõÆÂΩï
  lane :app_dir do
    current = Dir.pwd;
    puts "Dir.pwd: #{current}"

    current = File.expand_path("..", current);
    current = File.expand_path("..", current);

    appDir = "#{current}/build/app/outputs/flutter-ipa"
    puts "#{appDir}"
  end

  def update_build_number
    current = Dir.pwd;
    current = File.expand_path("..", current);
    
    # Ëé∑Âèñ Info.plist Êñá‰ª∂Ë∑ØÂæÑ
    plist_path = "#{current}/Runner/Info.plist"
  
    # ËØªÂèñÂΩìÂâçÁöÑ build number
    current_build_number = get_info_plist_value(
      path: plist_path,
      key: "CFBundleVersion"
    ).to_i
  
    # Ëá™Â¢û build number
    new_build_number = (current_build_number + 1).to_s
  
    # Êõ¥Êñ∞ Info.plist ‰∏≠ÁöÑ build number
    set_info_plist_value(
      path: plist_path,
      key: "CFBundleVersion",
      value: new_build_number
    )
  

    build_number = get_info_plist_value(
      path: plist_path,
      key: "CFBundleVersion"
    ).to_i
    puts "build_number:#{current_build_number} -> #{build_number}"
  end

  desc "ÊµãËØï"
  lane :test do |options|
    # clear_cache_files()
    # puts "user name is: #{`whoami`}"  

    # account = "#{`whoami`}".delete "\n"
    # tokenfiles = "/Users/#{account}/Library/Caches/com.apple.amp.itmstransporter/UploadTokens/*.token"
    # UI.message "Token: #{tokenfiles}"
    
    # handleDingSlack()
    # handleDingTalk()

    update_build_number();
  end


  # You can define as many lanes as you want
  after_all do |lane|

  end

  error do |lane, exception|

  end
end


# More information about multiple platforms in fastlane: https://github.com/fastlane/fastlane/blob/master/fastlane/docs/Platforms.md
# All available actions: https://docs.fastlane.tools/actions

# fastlane reports which actions are used. No personal data is recorded.
# Learn more at https://github.com/fastlane/fastlane#metrics


# fastlane ios developupload to: pgy